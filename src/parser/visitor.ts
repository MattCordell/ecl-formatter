import { CstNode, IToken } from "chevrotain";
import { parser } from "./parser";
import * as ast from "./ast";

// Get the base visitor class from the parser
const BaseEclVisitor = parser.getBaseCstVisitorConstructor();

/**
 * ECL CST (Concrete Syntax Tree) to AST (Abstract Syntax Tree) Visitor.
 *
 * This visitor implements the Visitor pattern to transform CST nodes generated by the
 * Chevrotain parser into a more structured and semantically meaningful AST representation.
 * The CST contains all parsing details including tokens and their positions, while the
 * AST provides a cleaner, type-safe tree structure optimized for formatting and analysis.
 *
 * The visitor uses Chevrotain's automatic visitor generation, where each grammar rule
 * corresponds to a visit method. The transformation process:
 * 1. Extracts meaningful tokens from CST nodes (removing syntax noise)
 * 2. Recursively visits child nodes to build nested structures
 * 3. Creates strongly-typed AST nodes matching types defined in ast.ts
 * 4. Handles optional grammar elements and combines multi-token patterns
 *
 * @example
 * // Parse ECL expression and transform to AST
 * const lexResult = lexer.tokenize("< 404684003 |Clinical finding|");
 * const parser = new EclParser();
 * parser.input = lexResult.tokens;
 * const cst = parser.expressionConstraint();
 * const ast = astVisitor.visit(cst);
 * // Result: { type: "SubExpression", constraintOperator: {...}, focusConcept: {...} }
 */
export class EclAstVisitor extends BaseEclVisitor {
  /**
   * Constructs the ECL AST visitor.
   *
   * Initializes the base Chevrotain visitor and validates that all grammar rules
   * have corresponding visitor methods, ensuring complete CST traversal coverage.
   */
  constructor() {
    super();
    this.validateVisitor();
  }

  /**
   * Transforms top-level expressionConstraint CST node to AST expression.
   *
   * This is the entry point for ECL parsing. Handles both simple expressions and
   * compound expressions joined by boolean operators (AND, OR, MINUS). For compound
   * expressions, builds a left-associative binary tree structure.
   *
   * @param ctx - CST context containing simpleOrRefinedExpression array and optional booleanOperator array
   * @returns CompoundExpression (if operators present), RefinedExpression, or SubExpression
   *
   * @example
   * Input CST: "< 404684003 AND > 123456789"
   * Output: {
   *   type: "CompoundExpression",
   *   operator: "AND",
   *   left: { type: "SubExpression", ... },
   *   right: { type: "SubExpression", ... }
   * }
   */
  expressionConstraint(ctx: any): ast.ExpressionConstraint["expression"] {
    const first = this.visit(ctx.simpleOrRefinedExpression[0]);

    // Check if this is a compound expression (has boolean operators)
    if (ctx.booleanOperator && ctx.booleanOperator.length > 0) {
      // Build compound expression chain
      let result = first;
      for (let i = 0; i < ctx.booleanOperator.length; i++) {
        const operator = this.visit(ctx.booleanOperator[i]);
        const right = this.visit(ctx.simpleOrRefinedExpression[i + 1]);
        result = {
          type: "CompoundExpression",
          operator,
          left: result,
          right,
        } as ast.CompoundExpression;
      }
      return result;
    }

    // Single expression (simple or refined)
    return first;
  }

  /**
   * Transforms simpleOrRefinedExpression CST node to SubExpression or RefinedExpression AST.
   *
   * Detects whether the expression includes a refinement (indicated by colon separator).
   * A refinement adds attribute constraints to the base concept expression.
   *
   * @param ctx - CST context containing subExpressionConstraint, optional Colon token, and optional eclRefinement
   * @returns RefinedExpression if colon and refinement present, otherwise SubExpression
   *
   * @example
   * Input CST: "< 404684003 : 363698007 = 123456789"
   * Output: {
   *   type: "RefinedExpression",
   *   expression: { type: "SubExpression", ... },
   *   refinement: { type: "Refinement", ... }
   * }
   */
  simpleOrRefinedExpression(ctx: any): ast.SubExpression | ast.RefinedExpression {
    const subExpr = this.visit(ctx.subExpressionConstraint[0]) as ast.SubExpression;

    // Check if this has a refinement
    if (ctx.Colon && ctx.eclRefinement) {
      return {
        type: "RefinedExpression",
        expression: subExpr,
        refinement: this.visit(ctx.eclRefinement[0]),
      } as ast.RefinedExpression;
    }

    return subExpr;
  }

  /**
   * Transforms booleanOperator CST node to string literal operator.
   *
   * Extracts the boolean operator token and returns its normalized string form.
   * Used in compound expressions to combine multiple constraints.
   *
   * @param ctx - CST context containing exactly one of: And, Or, or Minus token
   * @returns "AND", "OR", or "MINUS"
   *
   * @example
   * Input CST: And token
   * Output: "AND"
   */
  booleanOperator(ctx: any): "AND" | "OR" | "MINUS" {
    if (ctx.And) return "AND";
    if (ctx.Or) return "OR";
    if (ctx.Minus) return "MINUS";
    throw new Error("Unknown boolean operator");
  }

  /**
   * Transforms subExpressionConstraint CST node to SubExpression AST.
   *
   * Builds a complete sub-expression with optional constraint operator (e.g., <, <<),
   * required focus concept, optional filter constraints, and optional dotted attribute paths.
   *
   * If dotted notation is present (e.g., x . a . b), constructs a DottedAttributePath as the
   * focus concept, wrapping the base expression and chained attributes.
   *
   * @param ctx - CST context containing eclFocusConcept, optional constraintOperator, optional filterConstraint array, and optional Dot/eclAttributeName
   * @returns SubExpression with focusConcept (possibly dotted path) and optional constraintOperator and filters
   *
   * @example
   * Input CST: "<< 404684003 |Clinical finding| {{ term = \"diabetes\" }}"
   * Output: {
   *   type: "SubExpression",
   *   constraintOperator: { type: "ConstraintOperator", operator: "<<" },
   *   focusConcept: { type: "ConceptReference", sctId: "404684003", term: "Clinical finding" },
   *   filters: [{ type: "Filter", ... }]
   * }
   *
   * @example
   * Input CST: "< 125605004 . 363698007"
   * Output: {
   *   type: "SubExpression",
   *   focusConcept: {
   *     type: "DottedAttributePath",
   *     base: { type: "SubExpression", ... },
   *     attributes: [{ type: "SubExpression", ... }]
   *   }
   * }
   */
  subExpressionConstraint(ctx: any): ast.SubExpression {
    let focusConcept: ast.FocusConcept = this.visit(ctx.eclFocusConcept[0]);

    // Check for dotted path notation
    if (ctx.Dot && ctx.Dot.length > 0) {
      // Build base SubExpression first
      const baseSubExpr: ast.SubExpression = {
        type: "SubExpression",
        focusConcept,
      };

      if (ctx.constraintOperator) {
        baseSubExpr.constraintOperator = this.visit(ctx.constraintOperator[0]);
      }

      if (ctx.filterConstraint && ctx.filterConstraint.length > 0) {
        baseSubExpr.filters = ctx.filterConstraint.map((fc: any) => this.visit(fc));
      }

      // Extract dotted attributes
      const attributes = ctx.eclAttributeName.map((attr: any) =>
        this.visit(attr) as ast.SubExpression
      );

      // Create DottedAttributePath
      const dottedPath: ast.DottedAttributePath = {
        type: "DottedAttributePath",
        base: baseSubExpr,
        attributes,
      };

      // Return SubExpression with DottedAttributePath as focusConcept
      return {
        type: "SubExpression",
        focusConcept: dottedPath,
      };
    }

    // No dotted path - normal SubExpression
    const result: ast.SubExpression = {
      type: "SubExpression",
      focusConcept,
    };

    if (ctx.constraintOperator) {
      result.constraintOperator = this.visit(ctx.constraintOperator[0]);
    }

    if (ctx.filterConstraint && ctx.filterConstraint.length > 0) {
      result.filters = ctx.filterConstraint.map((fc: any) => this.visit(fc));
    }

    return result;
  }

  /**
   * Transforms constraintOperator CST node to ConstraintOperator AST.
   *
   * Handles both brief syntax (symbolic operators like <, <<, >) and long-form
   * keyword syntax (descendantOf, ancestorOf, etc.). Normalizes the operator to
   * a canonical string representation for semantic processing.
   *
   * @param ctx - CST context containing exactly one operator token (brief or keyword form)
   * @returns ConstraintOperator with operator string
   *
   * @example
   * Input CST: "<<" token
   * Output: { type: "ConstraintOperator", operator: "<<" }
   *
   * @example
   * Input CST: "descendantOrSelfOf" keyword
   * Output: { type: "ConstraintOperator", operator: "descendantOrSelfOf" }
   */
  constraintOperator(ctx: any): ast.ConstraintOperator {
    let operator: ast.ConstraintOperator["operator"];

    // Brief syntax
    if (ctx.ChildOrSelfOf) operator = "<<!";
    else if (ctx.DescendantOrSelfOf) operator = "<<";
    else if (ctx.ChildOf) operator = "<!";
    else if (ctx.DescendantOf) operator = "<";
    else if (ctx.ParentOrSelfOf) operator = ">>!";
    else if (ctx.AncestorOrSelfOf) operator = ">>";
    else if (ctx.ParentOf) operator = ">!";
    else if (ctx.AncestorOf) operator = ">";
    else if (ctx.MemberOf) operator = "^";
    // Long form
    else if (ctx.DescendantOrSelfOfKeyword) operator = "descendantOrSelfOf";
    else if (ctx.DescendantOfKeyword) operator = "descendantOf";
    else if (ctx.ChildOrSelfOfKeyword) operator = "childOrSelfOf";
    else if (ctx.ChildOfKeyword) operator = "childOf";
    else if (ctx.AncestorOrSelfOfKeyword) operator = "ancestorOrSelfOf";
    else if (ctx.AncestorOfKeyword) operator = "ancestorOf";
    else if (ctx.ParentOrSelfOfKeyword) operator = "parentOrSelfOf";
    else if (ctx.ParentOfKeyword) operator = "parentOf";
    else if (ctx.MemberOfKeyword) operator = "memberOf";
    else throw new Error("Unknown constraint operator");

    return { type: "ConstraintOperator", operator };
  }

  /**
   * Transforms eclFocusConcept CST node to FocusConcept AST union type.
   *
   * The focus concept is the central concept being constrained. Handles four types:
   * concept reference (SCTID with optional term), wildcard (*), nested parenthesized
   * expression, or alternate identifier (external coding system reference).
   *
   * @param ctx - CST context containing one of: eclConceptReference, Wildcard, expressionConstraint, or alternateIdentifier
   * @returns ConceptReference, WildcardConcept, NestedExpression, or AlternateIdentifier
   *
   * @example
   * Input CST: "404684003 |Clinical finding|"
   * Output: { type: "ConceptReference", sctId: "404684003", term: "Clinical finding" }
   *
   * @example
   * Input CST: "*" (wildcard)
   * Output: { type: "WildcardConcept" }
   *
   * @example
   * Input CST: "(< 404684003 OR > 123456789)"
   * Output: { type: "NestedExpression", expression: {...} }
   */
  eclFocusConcept(ctx: any): ast.FocusConcept {
    if (ctx.eclConceptReference) {
      return this.visit(ctx.eclConceptReference[0]);
    }
    if (ctx.Wildcard) {
      return { type: "WildcardConcept" } as ast.WildcardConcept;
    }
    if (ctx.expressionConstraint) {
      return {
        type: "NestedExpression",
        expression: this.visit(ctx.expressionConstraint[0]),
      } as ast.NestedExpression;
    }
    if (ctx.alternateIdentifier) {
      return this.visit(ctx.alternateIdentifier[0]);
    }
    throw new Error("Unknown focus concept type");
  }

  /**
   * Transforms eclConceptReference CST node to ConceptReference AST.
   *
   * Extracts the SNOMED CT Identifier (SCTID) and optional human-readable term.
   * The term is enclosed in pipes (|term|) in ECL syntax and is stripped during
   * transformation. Terms are optional and used for readability only.
   *
   * @param ctx - CST context containing SctId token and optional TermString token
   * @returns ConceptReference with sctId string and optional term string
   *
   * @example
   * Input CST: "404684003 |Clinical finding|"
   * Output: { type: "ConceptReference", sctId: "404684003", term: "Clinical finding" }
   *
   * @example
   * Input CST: "404684003"
   * Output: { type: "ConceptReference", sctId: "404684003" }
   */
  eclConceptReference(ctx: any): ast.ConceptReference {
    const sctId = ctx.SctId[0].image;
    let term: string | undefined;

    if (ctx.TermString) {
      // Remove the pipe delimiters
      const termWithPipes = ctx.TermString[0].image;
      term = termWithPipes.slice(1, -1).trim();
    }

    return { type: "ConceptReference", sctId, term };
  }

  /**
   * Transforms alternateIdentifier CST node to AlternateIdentifier AST.
   *
   * Alternate identifiers reference concepts from external coding systems (non-SNOMED).
   * Format is SCHEME#code, where SCHEME identifies the coding system and code is the
   * identifier in that system. Handles various code formats: string literals (quoted),
   * alphanumeric codes, SCTID-format codes, or additional identifiers.
   *
   * @param ctx - CST context containing Identifier array (scheme + optional code) and one of: StringLiteral, AlternateIdCode, or SctId
   * @returns AlternateIdentifier with scheme and code strings
   *
   * @example
   * Input CST: "ICD-10#E11.9"
   * Output: { type: "AlternateIdentifier", scheme: "ICD-10", code: "E11.9" }
   *
   * @example
   * Input CST: "LOINC#\"2339-0\""
   * Output: { type: "AlternateIdentifier", scheme: "LOINC", code: "2339-0" }
   */
  alternateIdentifier(ctx: any): ast.AlternateIdentifier {
    const scheme = ctx.Identifier[0].image;
    let code: string;

    if (ctx.StringLiteral) {
      // Remove quotes
      code = ctx.StringLiteral[0].image.slice(1, -1);
    } else if (ctx.AlternateIdCode) {
      code = ctx.AlternateIdCode[0].image;
    } else if (ctx.SctId) {
      code = ctx.SctId[0].image;
    } else if (ctx.Identifier && ctx.Identifier.length > 1) {
      code = ctx.Identifier[1].image;
    } else {
      throw new Error("Unknown alternate identifier code type");
    }

    return { type: "AlternateIdentifier", scheme, code };
  }

  /**
   * Transforms eclRefinement CST node to Refinement AST.
   *
   * Refinements add attribute constraints to concepts. Collects all refinement items
   * (attributes or attribute groups) and extracts the conjunctions (AND, OR, comma)
   * that join them. Maintains parallel arrays where conjunctions[i] connects items[i] and items[i+1].
   *
   * @param ctx - CST context containing eclRefinementItem array and optional And, Or, Comma token arrays
   * @returns Refinement with items array and conjunctions array
   *
   * @example
   * Input CST: "363698007 = 123456789 , 116676008 = 987654321"
   * Output: {
   *   type: "Refinement",
   *   items: [{ type: "Attribute", ... }, { type: "Attribute", ... }],
   *   conjunctions: [","]
   * }
   */
  eclRefinement(ctx: any): ast.Refinement {
    const items: ast.RefinementItem[] = [];
    const conjunctions: ("AND" | "OR" | ",")[] = [];

    // First item
    items.push(this.visit(ctx.eclRefinementItem[0]));

    // Additional items with conjunctions
    if (ctx.eclRefinementItem.length > 1) {
      for (let i = 1; i < ctx.eclRefinementItem.length; i++) {
        // Determine conjunction
        if (ctx.And && ctx.And[i - 1]) conjunctions.push("AND");
        else if (ctx.Or && ctx.Or[i - 1]) conjunctions.push("OR");
        else if (ctx.Comma && ctx.Comma[i - 1]) conjunctions.push(",");

        items.push(this.visit(ctx.eclRefinementItem[i]));
      }
    }

    return { type: "Refinement", items, conjunctions };
  }

  /**
   * Transforms eclRefinementItem CST node to RefinementItem AST union type.
   *
   * A refinement item is either an individual attribute or an attribute group (braced
   * set of attributes). Both can have optional cardinality constraints. This method
   * extracts the cardinality if present and attaches it to the appropriate item type.
   *
   * @param ctx - CST context containing optional cardinality and one of: eclAttributeGroup or subAttributeSet
   * @returns AttributeGroup, Attribute, or NestedAttributeSet, potentially with cardinality field
   *
   * @example
   * Input CST: "[1..*] { 363698007 = 123456789 }"
   * Output: {
   *   type: "AttributeGroup",
   *   cardinality: { type: "Cardinality", min: 1, max: "*" },
   *   items: [...],
   *   conjunctions: [...]
   * }
   */
  eclRefinementItem(ctx: any): ast.RefinementItem {
    let cardinality: ast.Cardinality | undefined;
    if (ctx.cardinality) {
      cardinality = this.visit(ctx.cardinality[0]);
    }

    if (ctx.eclAttributeGroup) {
      const group = this.visit(ctx.eclAttributeGroup[0]) as ast.AttributeGroup;
      if (cardinality) {
        group.cardinality = cardinality;
      }
      return group;
    }

    if (ctx.subAttributeSet) {
      const item = this.visit(ctx.subAttributeSet[0]) as ast.AttributeSetItem;
      // Cardinality can only apply to Attribute, not NestedAttributeSet
      if (cardinality && item.type === "Attribute") {
        (item as ast.Attribute).cardinality = cardinality;
      }
      return item;
    }

    throw new Error("Unknown refinement item type");
  }

  /**
   * Transforms eclAttributeGroup CST node to AttributeGroup AST.
   *
   * Attribute groups are braced sets of attributes ({ attr1, attr2 }) that represent
   * role groups in SNOMED CT. Delegates to eclAttributeSet to extract attributes and
   * conjunctions, then wraps the result in an AttributeGroup node.
   *
   * @param ctx - CST context containing eclAttributeSet (braced attribute list)
   * @returns AttributeGroup with items array and conjunctions array
   *
   * @example
   * Input CST: "{ 363698007 = 123456789 , 116676008 = 987654321 }"
   * Output: {
   *   type: "AttributeGroup",
   *   items: [{ type: "Attribute", ... }, { type: "Attribute", ... }],
   *   conjunctions: [","]
   * }
   */
  eclAttributeGroup(ctx: any): ast.AttributeGroup {
    const attrSet = this.visit(ctx.eclAttributeSet[0]);
    return {
      type: "AttributeGroup",
      items: attrSet.items,
      conjunctions: attrSet.conjunctions,
    };
  }

  /**
   * Transforms eclAttributeSet CST node to plain object with items and conjunctions.
   *
   * Helper method for extracting attribute set items and their joining conjunctions. Does
   * not create an AST node itself but returns raw data used by eclAttributeGroup and
   * eclRefinement. Maintains parallel arrays where conjunctions[i] joins items[i] and items[i+1].
   * Items can be either Attribute or NestedAttributeSet nodes.
   *
   * @param ctx - CST context containing subAttributeSet array and optional And, Or, Comma token arrays
   * @returns Plain object with items array and conjunctions array (not an AST node)
   *
   * @example
   * Input CST: "363698007 = 123456789 AND 116676008 = 987654321"
   * Output: {
   *   items: [{ type: "Attribute", ... }, { type: "Attribute", ... }],
   *   conjunctions: ["AND"]
   * }
   */
  eclAttributeSet(ctx: any): { items: ast.AttributeSetItem[]; conjunctions: ("AND" | "OR" | ",")[] } {
    const items: ast.AttributeSetItem[] = [];
    const conjunctions: ("AND" | "OR" | ",")[] = [];

    // First item (attribute or nested attribute set)
    items.push(this.visit(ctx.subAttributeSet[0]));

    // Additional items with conjunctions
    if (ctx.subAttributeSet.length > 1) {
      for (let i = 1; i < ctx.subAttributeSet.length; i++) {
        if (ctx.And && ctx.And[i - 1]) conjunctions.push("AND");
        else if (ctx.Or && ctx.Or[i - 1]) conjunctions.push("OR");
        else if (ctx.Comma && ctx.Comma[i - 1]) conjunctions.push(",");

        items.push(this.visit(ctx.subAttributeSet[i]));
      }
    }

    return { items, conjunctions };
  }

  /**
   * Transforms subAttributeSet CST node to AttributeSetItem AST.
   *
   * A sub-attribute set can be either a single attribute or a parenthesized attribute set.
   * This enables operator precedence grouping in complex attribute constraints.
   *
   * @param ctx - CST context containing either eclAttribute or parenthesizedAttributeSet
   * @returns Either an Attribute or a NestedAttributeSet
   *
   * @example
   * Input CST: "(363698007 = 123456789 OR 116676008 = 987654321)"
   * Output: {
   *   type: "NestedAttributeSet",
   *   items: [{ type: "Attribute", ... }, { type: "Attribute", ... }],
   *   conjunctions: ["OR"]
   * }
   */
  subAttributeSet(ctx: any): ast.AttributeSetItem {
    if (ctx.eclAttribute) {
      return this.visit(ctx.eclAttribute[0]);
    }
    if (ctx.parenthesizedAttributeSet) {
      return this.visit(ctx.parenthesizedAttributeSet[0]);
    }
    throw new Error("Unknown subAttributeSet type");
  }

  /**
   * Transforms parenthesizedAttributeSet CST node to NestedAttributeSet AST.
   *
   * Parenthesized attribute sets allow grouping attributes for operator precedence.
   *
   * @param ctx - CST context containing eclAttributeSet within parentheses
   * @returns NestedAttributeSet with items and conjunctions
   */
  parenthesizedAttributeSet(ctx: any): ast.NestedAttributeSet {
    const attrSet = this.visit(ctx.eclAttributeSet[0]);
    return {
      type: "NestedAttributeSet",
      items: attrSet.items,
      conjunctions: attrSet.conjunctions,
    };
  }

  /**
   * Transforms eclAttribute CST node to Attribute AST.
   *
   * An attribute is a name-value pair with a comparator (e.g., attributeName = value).
   * Attributes constrain relationships in SNOMED CT expressions. Can optionally include
   * a reverse flag (R or reverseOf) to navigate relationships in reverse direction.
   * Delegates to child visitor methods for each component.
   *
   * @param ctx - CST context containing optional reverse flag, eclAttributeName, comparator, and eclAttributeValue
   * @returns Attribute with optional reverseFlag boolean, name (SubExpression), comparator string, and value (various types)
   *
   * @example
   * Input CST: "R 363698007 = 123456789"
   * Output: {
   *   type: "Attribute",
   *   reverseFlag: true,
   *   name: { type: "SubExpression", focusConcept: {...} },
   *   comparator: "=",
   *   value: { type: "SubExpression", focusConcept: {...} }
   * }
   */
  eclAttribute(ctx: any): ast.Attribute {
    let reverseFlag = false;

    // Check for reverse flag: ReverseOf keyword or "R" identifier
    if (ctx.ReverseOf) {
      reverseFlag = true;
    } else if (ctx.ReverseR) {
      // Validate that Identifier is "R" (case-insensitive)
      const ident = ctx.ReverseR[0].image;
      if (ident.toUpperCase() === 'R') {
        reverseFlag = true;
      } else {
        throw new Error(`Invalid reverse flag identifier: ${ident}. Expected 'R'.`);
      }
    }

    // Handle numeric values (# prefix) vs other value types
    let value: ast.AttributeValue;
    if (ctx.Hash && ctx.numericValue) {
      value = this.visit(ctx.numericValue[0]);
    } else if (ctx.eclAttributeValue) {
      value = this.visit(ctx.eclAttributeValue[0]);
    } else {
      throw new Error("Attribute must have a value");
    }

    return {
      type: "Attribute",
      reverseFlag: reverseFlag || undefined,  // Only include if true
      name: this.visit(ctx.eclAttributeName[0]),
      comparator: this.visit(ctx.comparator[0]),
      value: value,
    };
  }

  /**
   * Transforms eclAttributeName CST node to AttributeName (SubExpression) AST.
   *
   * Attribute names are sub-expressions that identify SNOMED CT relationship types.
   * This builds a SubExpression from the constraint operator, focus concept, and filters,
   * similar to subExpressionConstraint but without dotted path support.
   *
   * @param ctx - CST context containing optional constraintOperator, eclFocusConcept, and optional filterConstraints
   * @returns SubExpression representing the attribute name
   *
   * @example
   * Input CST: "<< 363698007"
   * Output: {
   *   type: "SubExpression",
   *   constraintOperator: { type: "ConstraintOperator", operator: "<<" },
   *   focusConcept: { type: "ConceptReference", sctId: "363698007" }
   * }
   */
  eclAttributeName(ctx: any): ast.AttributeName {
    const result: ast.SubExpression = {
      type: "SubExpression",
      focusConcept: this.visit(ctx.eclFocusConcept[0]),
    };

    if (ctx.constraintOperator) {
      result.constraintOperator = this.visit(ctx.constraintOperator[0]);
    }

    if (ctx.filterConstraint && ctx.filterConstraint.length > 0) {
      result.filters = ctx.filterConstraint.map((fc: any) => this.visit(fc));
    }

    return result;
  }

  /**
   * Transforms comparator CST node to string literal comparator.
   *
   * Comparators define the relationship between attribute names and values. Supports
   * equality (=, !=), numeric/ordering (<, <=, >, >=), and concept hierarchy operators
   * (< for descendant, > for ancestor).
   *
   * @param ctx - CST context containing one comparator token: Equals, NotEquals, LessThanOrEquals, GreaterThanOrEquals, DescendantOf, or AncestorOf
   * @returns String literal: "=", "!=", "<=", ">=", "<", or ">"
   *
   * @example
   * Input CST: Equals token
   * Output: "="
   */
  comparator(ctx: any): ast.Attribute["comparator"] {
    if (ctx.Equals) return "=";
    if (ctx.NotEquals) return "!=";
    if (ctx.LessThanOrEquals) return "<=";
    if (ctx.GreaterThanOrEquals) return ">=";
    if (ctx.DescendantOf) return "<";
    if (ctx.AncestorOf) return ">";
    throw new Error("Unknown comparator");
  }

  /**
   * Transforms eclAttributeValue CST node to AttributeValue AST union type.
   *
   * Attribute values can be concept expressions (for relationship targets) or concrete
   * data values (strings, numbers, booleans). Nested expressions are parenthesized compound
   * expressions. String literals have quotes stripped, integers are parsed to numbers.
   *
   * @param ctx - CST context containing one of: expressionConstraint, subExpressionConstraint, StringLiteral, Integer, True, or False
   * @returns NestedExpression, SubExpression, StringValue, NumberValue, or BooleanValue
   *
   * @example
   * Input CST: "123456789" (concept reference)
   * Output: { type: "SubExpression", focusConcept: {...} }
   *
   * @example
   * Input CST: "\"diabetes\"" (string literal)
   * Output: { type: "StringValue", value: "diabetes" }
   *
   * @example
   * Input CST: "5" (integer)
   * Output: { type: "NumberValue", value: 5 }
   */
  eclAttributeValue(ctx: any): ast.AttributeValue {
    if (ctx.expressionConstraint) {
      return {
        type: "NestedExpression",
        expression: this.visit(ctx.expressionConstraint[0]),
      } as ast.NestedExpression;
    }
    if (ctx.subExpressionConstraint) {
      return this.visit(ctx.subExpressionConstraint[0]);
    }
    if (ctx.StringLiteral) {
      return {
        type: "StringValue",
        value: ctx.StringLiteral[0].image.slice(1, -1),
      } as ast.StringValue;
    }
    if (ctx.Integer) {
      return {
        type: "NumberValue",
        value: parseInt(ctx.Integer[0].image, 10),
      } as ast.NumberValue;
    }
    if (ctx.True) {
      return { type: "BooleanValue", value: true } as ast.BooleanValue;
    }
    if (ctx.False) {
      return { type: "BooleanValue", value: false } as ast.BooleanValue;
    }
    throw new Error("Unknown attribute value type");
  }

  /**
   * Transforms numeric concrete domain values from CST to AST.
   *
   * Converts decimal and integer tokens into NumberValue AST nodes.
   * The # prefix is consumed by the parser and not included in the value.
   * Supports unsigned integers, signed integers, and decimal values.
   *
   * @param ctx - CST context containing DecimalValue, SignedInteger, or Integer tokens
   * @returns NumberValue AST node with parsed numeric value
   *
   * @example
   * Input CST: DecimalValue["12.5"]
   * Output: { type: "NumberValue", value: 12.5 }
   *
   * @example
   * Input CST: SignedInteger["-10"]
   * Output: { type: "NumberValue", value: -10 }
   */
  numericValue(ctx: any): ast.NumberValue {
    if (ctx.DecimalValue) {
      return {
        type: "NumberValue",
        value: parseFloat(ctx.DecimalValue[0].image),
      } as ast.NumberValue;
    }
    if (ctx.SignedInteger) {
      return {
        type: "NumberValue",
        value: parseInt(ctx.SignedInteger[0].image, 10),
      } as ast.NumberValue;
    }
    if (ctx.Integer) {
      return {
        type: "NumberValue",
        value: parseInt(ctx.Integer[0].image, 10),
      } as ast.NumberValue;
    }
    throw new Error("Unknown numeric value type");
  }

  /**
   * Transforms cardinality CST node to Cardinality AST.
   *
   * Cardinality specifies min/max occurrence constraints for attributes or attribute groups,
   * using syntax [min..max]. Values can be integers or wildcard (*) for unbounded. This method
   * collects all integer and wildcard tokens, sorts them by position to determine which is min
   * and which is max, then parses them appropriately.
   *
   * @param ctx - CST context containing Integer token array and/or Wildcard token array (exactly 2 total)
   * @returns Cardinality with min and max (each is number or "*")
   *
   * @example
   * Input CST: "[1..5]"
   * Output: { type: "Cardinality", min: 1, max: 5 }
   *
   * @example
   * Input CST: "[0..*]"
   * Output: { type: "Cardinality", min: 0, max: "*" }
   */
  cardinality(ctx: any): ast.Cardinality {
    // Collect all min/max tokens and sort by position
    const allTokens: Array<{ token: any; isWildcard: boolean }> = [];

    if (ctx.Integer) {
      for (const token of ctx.Integer) {
        allTokens.push({ token, isWildcard: false });
      }
    }
    if (ctx.Wildcard) {
      for (const token of ctx.Wildcard) {
        allTokens.push({ token, isWildcard: true });
      }
    }

    // Sort by start offset to get [min, max] order
    allTokens.sort((a, b) => a.token.startOffset - b.token.startOffset);

    const minEntry = allTokens[0];
    const maxEntry = allTokens[1];

    const min = minEntry.isWildcard ? "*" : parseInt(minEntry.token.image, 10);
    const max = maxEntry.isWildcard ? "*" : parseInt(maxEntry.token.image, 10);

    return { type: "Cardinality", min, max };
  }

  /**
   * Transforms filterConstraint CST node to Filter AST.
   *
   * Simple passthrough method that unwraps the CST node and delegates to
   * filterExpressionConstraint. Filters are enclosed in double braces {{ ... }}.
   *
   * @param ctx - CST context containing filterExpressionConstraint
   * @returns Filter with constraints array and conjunctions array
   *
   * @example
   * Input CST: "{{ term = \"diabetes\" }}"
   * Output: { type: "Filter", constraints: [...], conjunctions: [] }
   */
  filterConstraint(ctx: any): ast.Filter {
    return this.visit(ctx.filterExpressionConstraint[0]);
  }

  /**
   * Transforms filterExpressionConstraint CST node to Filter AST.
   *
   * Collects all individual filter constraints (term, language, type, etc.) and the
   * AND/OR conjunctions joining them. Maintains parallel arrays where conjunctions[i]
   * joins constraints[i] and constraints[i+1].
   *
   * @param ctx - CST context containing filter array and optional And, Or token arrays
   * @returns Filter with constraints array and conjunctions array
   *
   * @example
   * Input CST: "term = \"diabetes\" AND language en"
   * Output: {
   *   type: "Filter",
   *   constraints: [{ type: "TermFilter", ... }, { type: "LanguageFilter", ... }],
   *   conjunctions: ["AND"]
   * }
   */
  filterExpressionConstraint(ctx: any): ast.Filter {
    const constraints: ast.FilterConstraint[] = [];
    const conjunctions: ("AND" | "OR")[] = [];

    constraints.push(this.visit(ctx.filter[0]));

    if (ctx.filter.length > 1) {
      for (let i = 1; i < ctx.filter.length; i++) {
        if (ctx.And && ctx.And[i - 1]) conjunctions.push("AND");
        else if (ctx.Or && ctx.Or[i - 1]) conjunctions.push("OR");

        constraints.push(this.visit(ctx.filter[i]));
      }
    }

    return { type: "Filter", constraints, conjunctions };
  }

  /**
   * Transforms filter CST node to FilterConstraint AST union type.
   *
   * Dispatcher method that identifies the specific filter type (term, language, type, dialect,
   * module, active, or definition status) and delegates to the appropriate specialized visitor.
   *
   * @param ctx - CST context containing exactly one of: termFilter, languageFilter, typeFilter, dialectFilter, moduleFilter, activeFilter, or definitionStatusFilter
   * @returns One of: TermFilter, LanguageFilter, TypeFilter, DialectFilter, ModuleFilter, ActiveFilter, or DefinitionStatusFilter
   *
   * @example
   * Input CST: termFilter node
   * Output: { type: "TermFilter", ... }
   */
  filter(ctx: any): ast.FilterConstraint {
    if (ctx.termFilter) return this.visit(ctx.termFilter[0]);
    if (ctx.languageFilter) return this.visit(ctx.languageFilter[0]);
    if (ctx.typeFilter) return this.visit(ctx.typeFilter[0]);
    if (ctx.dialectFilter) return this.visit(ctx.dialectFilter[0]);
    if (ctx.moduleFilter) return this.visit(ctx.moduleFilter[0]);
    if (ctx.activeFilter) return this.visit(ctx.activeFilter[0]);
    if (ctx.definitionStatusFilter) return this.visit(ctx.definitionStatusFilter[0]);
    throw new Error("Unknown filter type");
  }

  /**
   * Transforms termFilter CST node to TermFilter AST.
   *
   * Term filters constrain results based on description text matching. Optional operator
   * specifies match type: "match" for exact/regex matching, "wild" for wildcard matching,
   * or undefined for default term matching. Multiple string values can be provided.
   * Quotes are stripped from string literals.
   *
   * @param ctx - CST context containing optional Match/Wild token and StringLiteral token array
   * @returns TermFilter with optional operator and values array
   *
   * @example
   * Input CST: "term = \"diabetes\""
   * Output: { type: "TermFilter", operator: undefined, values: ["diabetes"] }
   *
   * @example
   * Input CST: "term wild \"diabet*\""
   * Output: { type: "TermFilter", operator: "wild", values: ["diabet*"] }
   */
  termFilter(ctx: any): ast.TermFilter {
    let operator: "match" | "wild" | undefined;
    if (ctx.Match) operator = "match";
    if (ctx.Wild) operator = "wild";

    // Collect all string literal values (there may be multiple)
    const values = ctx.StringLiteral.map((token: any) => token.image.slice(1, -1));

    return {
      type: "TermFilter",
      operator,
      values,
    };
  }

  /**
   * Transforms languageFilter CST node to LanguageFilter AST.
   *
   * Language filters constrain results to descriptions in a specific language, identified
   * by a dialect alias (e.g., "en" for English, "es" for Spanish). The alias is extracted
   * directly from the DialectAlias token.
   *
   * @param ctx - CST context containing DialectAlias token
   * @returns LanguageFilter with value string (dialect alias)
   *
   * @example
   * Input CST: "language en"
   * Output: { type: "LanguageFilter", value: "en" }
   */
  languageFilter(ctx: any): ast.LanguageFilter {
    return {
      type: "LanguageFilter",
      value: ctx.DialectAlias[0].image,
    };
  }

  /**
   * Transforms typeFilter CST node to TypeFilter AST.
   *
   * Type filters constrain description types. Value can be predefined constants (PREFERRED,
   * ACCEPTABLE) or a concept reference to a description type concept. Handles keyword tokens
   * and delegates to eclConceptReference for concept-based types.
   *
   * @param ctx - CST context containing one of: Preferred, Acceptable, or eclConceptReference
   * @returns TypeFilter with value (string literal or ConceptReference)
   *
   * @example
   * Input CST: "type PREFERRED"
   * Output: { type: "TypeFilter", value: "PREFERRED" }
   *
   * @example
   * Input CST: "type 900000000000013009"
   * Output: { type: "TypeFilter", value: { type: "ConceptReference", sctId: "900000000000013009" } }
   */
  typeFilter(ctx: any): ast.TypeFilter {
    let value: ast.TypeFilter["value"];
    if (ctx.Preferred) value = "PREFERRED";
    else if (ctx.Acceptable) value = "ACCEPTABLE";
    else if (ctx.eclConceptReference) value = this.visit(ctx.eclConceptReference[0]);
    else throw new Error("Unknown type filter value");

    return { type: "TypeFilter", value };
  }

  /**
   * Transforms dialectFilter CST node to DialectFilter AST.
   *
   * Dialect filters constrain results to descriptions acceptable in a specific dialect,
   * with optional acceptability (PREFERRED or ACCEPTABLE). Dialect can be specified as
   * an alias string or a concept reference. Acceptability is optional.
   *
   * @param ctx - CST context containing (DialectAlias or eclConceptReference) and optional (Preferred or Acceptable)
   * @returns DialectFilter with value (string or ConceptReference) and optional acceptability
   *
   * @example
   * Input CST: "dialect en-us PREFERRED"
   * Output: { type: "DialectFilter", value: "en-us", acceptability: "PREFERRED" }
   *
   * @example
   * Input CST: "dialect 900000000000509007"
   * Output: { type: "DialectFilter", value: { type: "ConceptReference", sctId: "900000000000509007" } }
   */
  dialectFilter(ctx: any): ast.DialectFilter {
    let value: ast.DialectFilter["value"];
    if (ctx.DialectAlias) value = ctx.DialectAlias[0].image;
    else if (ctx.eclConceptReference) value = this.visit(ctx.eclConceptReference[0]);
    else throw new Error("Unknown dialect filter value");

    let acceptability: ast.DialectFilter["acceptability"];
    if (ctx.Preferred) acceptability = "PREFERRED";
    else if (ctx.Acceptable) acceptability = "ACCEPTABLE";

    return { type: "DialectFilter", value, acceptability };
  }

  /**
   * Transforms moduleFilter CST node to ModuleFilter AST.
   *
   * Module filters constrain results to components from a specific SNOMED CT module.
   * The module is identified by a concept reference (SCTID). Unwraps the CST node and
   * delegates to eclConceptReference.
   *
   * @param ctx - CST context containing eclConceptReference
   * @returns ModuleFilter with value (ConceptReference)
   *
   * @example
   * Input CST: "module 900000000000207008"
   * Output: {
   *   type: "ModuleFilter",
   *   value: { type: "ConceptReference", sctId: "900000000000207008" }
   * }
   */
  moduleFilter(ctx: any): ast.ModuleFilter {
    return {
      type: "ModuleFilter",
      value: this.visit(ctx.eclConceptReference[0]),
    };
  }

  /**
   * Transforms activeFilter CST node to ActiveFilter AST.
   *
   * Active filters constrain results based on component active status (active or inactive).
   * Checks for True token presence and converts to boolean. False is implied by absence of True.
   *
   * @param ctx - CST context containing True or False token
   * @returns ActiveFilter with value (boolean)
   *
   * @example
   * Input CST: "active true"
   * Output: { type: "ActiveFilter", value: true }
   *
   * @example
   * Input CST: "active false"
   * Output: { type: "ActiveFilter", value: false }
   */
  activeFilter(ctx: any): ast.ActiveFilter {
    return {
      type: "ActiveFilter",
      value: !!ctx.True,
    };
  }

  /**
   * Transforms definitionStatusFilter CST node to DefinitionStatusFilter AST.
   *
   * Definition status filters constrain results based on concept definition status
   * (primitive vs. fully defined). Value can be predefined constants (PRIMITIVE, DEFINED)
   * or a concept reference to a definition status concept.
   *
   * @param ctx - CST context containing one of: Primitive, Defined, or eclConceptReference
   * @returns DefinitionStatusFilter with value (string literal or ConceptReference)
   *
   * @example
   * Input CST: "definitionStatus PRIMITIVE"
   * Output: { type: "DefinitionStatusFilter", value: "PRIMITIVE" }
   *
   * @example
   * Input CST: "definitionStatus 900000000000074008"
   * Output: {
   *   type: "DefinitionStatusFilter",
   *   value: { type: "ConceptReference", sctId: "900000000000074008" }
   * }
   */
  definitionStatusFilter(ctx: any): ast.DefinitionStatusFilter {
    let value: ast.DefinitionStatusFilter["value"];
    if (ctx.Primitive) value = "PRIMITIVE";
    else if (ctx.Defined) value = "DEFINED";
    else if (ctx.eclConceptReference) value = this.visit(ctx.eclConceptReference[0]);
    else throw new Error("Unknown definition status filter value");

    return { type: "DefinitionStatusFilter", value };
  }
}

/**
 * Singleton visitor instance for CST to AST transformation.
 *
 * Reusable visitor instance that can be used across multiple parse operations.
 * Maintains no internal state between visits, making it safe for concurrent use.
 */
export const astVisitor = new EclAstVisitor();

/**
 * Helper function to build AST from CST.
 *
 * Convenience wrapper around the singleton visitor's visit method. Takes a CST
 * node produced by the parser and transforms it into a typed AST structure.
 *
 * @param cst - CST node from parser (typically result of parser.expressionConstraint())
 * @returns Typed AST expression (CompoundExpression, RefinedExpression, or SubExpression)
 *
 * @example
 * const lexResult = lexer.tokenize("< 404684003");
 * parser.input = lexResult.tokens;
 * const cst = parser.expressionConstraint();
 * const ast = buildAst(cst);
 */
export function buildAst(cst: CstNode): ast.ExpressionConstraint["expression"] {
  return astVisitor.visit(cst);
}
